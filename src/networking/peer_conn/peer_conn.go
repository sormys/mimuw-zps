package peer_conn

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"log/slog"
	"mimuw_zps/src/encryption"
	"mimuw_zps/src/networking/srv_conn"
	"net"
)

// All errors was generated by Copilot

type Peer struct {
	name      string
	addresses []string
	key       encryption.Key
}

// Which address to use? I had to set it to nil, otherwise it would not work
// If you set nil, Go chooses the first non-loopback address
var addr = net.UDPAddr{
	Port: 2139,
	IP:   nil,
}

type Message []byte

type HandshakeType struct {
	ID         []byte
	Type       []byte
	Length     []byte
	Extensions []byte
	Name       []byte
}

var (
	HELLO        = Message([]byte{0x00})
	EMPTY_LENGTH = Message([]byte{0x00, 0x00})
	HELLO_REPLY  = Message([]byte{0x82})
	ERROR        = Message([]byte{0x81})
)

func NewPeer(name string, addresses []string, key encryption.Key) Peer {
	return Peer{name: name, addresses: addresses, key: key}
}

func getExtensions() []byte {
	return []byte{0x00, 0x00, 0x00, 0x00}
}

func (p Peer) decodeHandshake(data []byte) HandshakeType {
	id := data[:4]
	typeMessage := data[4:5]
	length := data[5:7]
	extensions := data[7:11]
	name := data[11 : 11+length[0]]
	return HandshakeType{id, typeMessage, length, extensions, name}
}

func (p Peer) encodeError(id []byte, errorMessage string) []byte {
	message := make([]byte, 0)
	message = append(message, id...)
	message = append(message, ERROR...)

	messageByte := []byte(errorMessage)
	buffor := new(bytes.Buffer)
	err := binary.Write(buffor, binary.LittleEndian, uint16(len(messageByte)))
	if err != nil {
		slog.Error("Failed to write length of error message", "error", err)
		return nil
	}
	message = append(message, buffor.Bytes()...)
	message = append(message, messageByte...)
	return message
}

func (p Peer) encodeHandshake(typeMessage Message, id []byte) []byte {
	extensions := getExtensions()
	name := []byte(p.name)
	length := EMPTY_LENGTH

	message := make([]byte, 0)
	message = append(message, id...)
	message = append(message, typeMessage...)
	message = append(message, length...)
	message = append(message, extensions...)
	message = append(message, name...)

	return message
}

// Sometimes I expect conn(during sending), sometimes I dont care -> what should I do?
func (p Peer) SendMessage(peer Peer, data []byte) *net.UDPConn {
	conn, err := net.ListenUDP("udp", &addr)
	if err != nil {
		slog.Error("Failed to listen on UDP", "error", err)
		return nil
	}
	defer conn.Close()

	//which address to use?
	raddr, err := net.ResolveUDPAddr("udp", peer.addresses[0])
	if err != nil {
		slog.Error("Failed to resolve UDP address", "error", err)
		return nil
	}

	_, err = conn.WriteTo(data, raddr)
	fmt.Println("Sent data to", raddr)

	if err != nil {
		slog.Error("Failed to send handshake", "error", err)
	}
	return conn
}

// maybe one main thread should listen for incoming messages -> then we dont need to return conn in SendMessage
func (p Peer) SendHandshake(peer Peer) bool {

	message := p.encodeHandshake(HELLO, make([]byte, 4))
	data := encryption.SignatureMessage(message)

	conn := p.SendMessage(peer, data)

	//how big should the buffer be?
	buf := make([]byte, 1024)
	n, _, err := conn.ReadFrom(buf)
	if err != nil {
		slog.Error("Failed to read handshake response", "error", err)
	}

	fmt.Println("Received response:", buf[:n])
	handshake := p.decodeHandshake(buf[:n])

	if bytes.Equal(handshake.ID, message[:4]) {
		slog.Error("Failed to match handshake ID", "error", err)
		return false
	}

	if handshake.Type[0] != HELLO_REPLY[0] {
		slog.Error("Failed to receive handshake response", "error", err)
		return false
	}

	return true
}

// assume that main thread recognized that is the HELLO_REPLY and invoke this function
func (p Peer) ReceiveHandshake(peer Peer, data []byte) bool {

	// How to get Server Instance?
	url := "https://galene.org:8448/"
	server := srv_conn.NewServer(url)

	key, error := server.GetPeerKey(peer.name)
	if error != nil {
		slog.Error("Failed to get peer key", "error", error)
		return false
	}
	if !encryption.VerifySignature(data, peer.key[:], encryption.ParsePublicKey(key)) {
		p.SendMessage(peer, p.encodeError(data[:4], "Signature verification failed"))
		return false
	}
	data = p.encodeHandshake(HELLO_REPLY, data[:4])
	conn := p.SendMessage(peer, data)
	if conn == nil {
		slog.Error("Failed to send handshake response", "error", error)
		return false
	}
	fmt.Println("Sent handshake response:", data)
	return true
}
